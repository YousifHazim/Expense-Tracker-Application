{"ast":null,"code":"\"use strict\";\n\nexports.lightFormat = lightFormat;\nObject.defineProperty(exports, \"lightFormatters\", {\n  enumerable: true,\n  get: function () {\n    return _index3.lightFormatters;\n  }\n});\nvar _index = require(\"./isValid.js\");\nvar _index2 = require(\"./toDate.js\");\nvar _index3 = require(\"./_lib/format/lightFormatters.js\");\n\n// Rexports of internal for libraries to use.\n// See: https://github.com/date-fns/date-fns/issues/3638#issuecomment-1877082874\n\n// This RegExp consists of three parts separated by `|`:\n// - (\\w)\\1* matches any sequences of the same letter\n// - '' matches two quote characters in a row\n// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),\n//   except a single quote symbol, which ends the sequence.\n//   Two quote characters do not end the sequence.\n//   If there is no matching single quote\n//   then the sequence will continue until the end of the string.\n// - . matches any single character unmatched by previous parts of the RegExps\nconst formattingTokensRegExp = /(\\w)\\1*|''|'(''|[^'])+('|$)|./g;\nconst escapedStringRegExp = /^'([^]*?)'?$/;\nconst doubleQuoteRegExp = /''/g;\nconst unescapedLatinCharacterRegExp = /[a-zA-Z]/;\n\n/**\r\n * @private\r\n */\n\n/**\r\n * @name lightFormat\r\n * @category Common Helpers\r\n * @summary Format the date.\r\n *\r\n * @description\r\n * Return the formatted date string in the given format. Unlike `format`,\r\n * `lightFormat` doesn't use locales and outputs date using the most popular tokens.\r\n *\r\n * > ⚠️ Please note that the `lightFormat` tokens differ from Moment.js and other libraries.\r\n * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md\r\n *\r\n * The characters wrapped between two single quotes characters (') are escaped.\r\n * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.\r\n *\r\n * Format of the string is based on Unicode Technical Standard #35:\r\n * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\r\n *\r\n * Accepted patterns:\r\n * | Unit                            | Pattern | Result examples                   |\r\n * |---------------------------------|---------|-----------------------------------|\r\n * | AM, PM                          | a..aaa  | AM, PM                            |\r\n * |                                 | aaaa    | a.m., p.m.                        |\r\n * |                                 | aaaaa   | a, p                              |\r\n * | Calendar year                   | y       | 44, 1, 1900, 2017                 |\r\n * |                                 | yy      | 44, 01, 00, 17                    |\r\n * |                                 | yyy     | 044, 001, 000, 017                |\r\n * |                                 | yyyy    | 0044, 0001, 1900, 2017            |\r\n * | Month (formatting)              | M       | 1, 2, ..., 12                     |\r\n * |                                 | MM      | 01, 02, ..., 12                   |\r\n * | Day of month                    | d       | 1, 2, ..., 31                     |\r\n * |                                 | dd      | 01, 02, ..., 31                   |\r\n * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |\r\n * |                                 | hh      | 01, 02, ..., 11, 12               |\r\n * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |\r\n * |                                 | HH      | 00, 01, 02, ..., 23               |\r\n * | Minute                          | m       | 0, 1, ..., 59                     |\r\n * |                                 | mm      | 00, 01, ..., 59                   |\r\n * | Second                          | s       | 0, 1, ..., 59                     |\r\n * |                                 | ss      | 00, 01, ..., 59                   |\r\n * | Fraction of second              | S       | 0, 1, ..., 9                      |\r\n * |                                 | SS      | 00, 01, ..., 99                   |\r\n * |                                 | SSS     | 000, 001, ..., 999                |\r\n * |                                 | SSSS    | ...                               |\r\n *\r\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\r\n *\r\n * @param date - The original date\r\n * @param format - The string of tokens\r\n *\r\n * @returns The formatted date string\r\n *\r\n * @throws `Invalid time value` if the date is invalid\r\n * @throws format string contains an unescaped latin alphabet character\r\n *\r\n * @example\r\n * const result = lightFormat(new Date(2014, 1, 11), 'yyyy-MM-dd')\r\n * //=> '2014-02-11'\r\n */\nfunction lightFormat(date, formatStr) {\n  const _date = (0, _index2.toDate)(date);\n  if (!(0, _index.isValid)(_date)) {\n    throw new RangeError(\"Invalid time value\");\n  }\n  const tokens = formatStr.match(formattingTokensRegExp);\n\n  // The only case when formattingTokensRegExp doesn't match the string is when it's empty\n  if (!tokens) return \"\";\n  const result = tokens.map(substring => {\n    // Replace two single quote characters with one single quote character\n    if (substring === \"''\") {\n      return \"'\";\n    }\n    const firstCharacter = substring[0];\n    if (firstCharacter === \"'\") {\n      return cleanEscapedString(substring);\n    }\n    const formatter = _index3.lightFormatters[firstCharacter];\n    if (formatter) {\n      return formatter(_date, substring);\n    }\n    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {\n      throw new RangeError(\"Format string contains an unescaped latin alphabet character `\" + firstCharacter + \"`\");\n    }\n    return substring;\n  }).join(\"\");\n  return result;\n}\nfunction cleanEscapedString(input) {\n  const matches = input.match(escapedStringRegExp);\n  if (!matches) {\n    return input;\n  }\n  return matches[1].replace(doubleQuoteRegExp, \"'\");\n}","map":{"version":3,"names":["exports","lightFormat","Object","defineProperty","enumerable","get","_index3","lightFormatters","_index","require","_index2","formattingTokensRegExp","escapedStringRegExp","doubleQuoteRegExp","unescapedLatinCharacterRegExp","date","formatStr","_date","toDate","isValid","RangeError","tokens","match","result","map","substring","firstCharacter","cleanEscapedString","formatter","join","input","matches","replace"],"sources":["D:/Faculty/Spring 2024/SW engineering/project/Expense-Tracker-Application/frontend/node_modules/date-fns/lightFormat.js"],"sourcesContent":["\"use strict\";\r\nexports.lightFormat = lightFormat;\r\nObject.defineProperty(exports, \"lightFormatters\", {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _index3.lightFormatters;\r\n  },\r\n});\r\nvar _index = require(\"./isValid.js\");\r\nvar _index2 = require(\"./toDate.js\");\r\nvar _index3 = require(\"./_lib/format/lightFormatters.js\");\r\n\r\n// Rexports of internal for libraries to use.\r\n// See: https://github.com/date-fns/date-fns/issues/3638#issuecomment-1877082874\r\n\r\n// This RegExp consists of three parts separated by `|`:\r\n// - (\\w)\\1* matches any sequences of the same letter\r\n// - '' matches two quote characters in a row\r\n// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),\r\n//   except a single quote symbol, which ends the sequence.\r\n//   Two quote characters do not end the sequence.\r\n//   If there is no matching single quote\r\n//   then the sequence will continue until the end of the string.\r\n// - . matches any single character unmatched by previous parts of the RegExps\r\nconst formattingTokensRegExp = /(\\w)\\1*|''|'(''|[^'])+('|$)|./g;\r\n\r\nconst escapedStringRegExp = /^'([^]*?)'?$/;\r\nconst doubleQuoteRegExp = /''/g;\r\nconst unescapedLatinCharacterRegExp = /[a-zA-Z]/;\r\n\r\n/**\r\n * @private\r\n */\r\n\r\n/**\r\n * @name lightFormat\r\n * @category Common Helpers\r\n * @summary Format the date.\r\n *\r\n * @description\r\n * Return the formatted date string in the given format. Unlike `format`,\r\n * `lightFormat` doesn't use locales and outputs date using the most popular tokens.\r\n *\r\n * > ⚠️ Please note that the `lightFormat` tokens differ from Moment.js and other libraries.\r\n * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md\r\n *\r\n * The characters wrapped between two single quotes characters (') are escaped.\r\n * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.\r\n *\r\n * Format of the string is based on Unicode Technical Standard #35:\r\n * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\r\n *\r\n * Accepted patterns:\r\n * | Unit                            | Pattern | Result examples                   |\r\n * |---------------------------------|---------|-----------------------------------|\r\n * | AM, PM                          | a..aaa  | AM, PM                            |\r\n * |                                 | aaaa    | a.m., p.m.                        |\r\n * |                                 | aaaaa   | a, p                              |\r\n * | Calendar year                   | y       | 44, 1, 1900, 2017                 |\r\n * |                                 | yy      | 44, 01, 00, 17                    |\r\n * |                                 | yyy     | 044, 001, 000, 017                |\r\n * |                                 | yyyy    | 0044, 0001, 1900, 2017            |\r\n * | Month (formatting)              | M       | 1, 2, ..., 12                     |\r\n * |                                 | MM      | 01, 02, ..., 12                   |\r\n * | Day of month                    | d       | 1, 2, ..., 31                     |\r\n * |                                 | dd      | 01, 02, ..., 31                   |\r\n * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |\r\n * |                                 | hh      | 01, 02, ..., 11, 12               |\r\n * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |\r\n * |                                 | HH      | 00, 01, 02, ..., 23               |\r\n * | Minute                          | m       | 0, 1, ..., 59                     |\r\n * |                                 | mm      | 00, 01, ..., 59                   |\r\n * | Second                          | s       | 0, 1, ..., 59                     |\r\n * |                                 | ss      | 00, 01, ..., 59                   |\r\n * | Fraction of second              | S       | 0, 1, ..., 9                      |\r\n * |                                 | SS      | 00, 01, ..., 99                   |\r\n * |                                 | SSS     | 000, 001, ..., 999                |\r\n * |                                 | SSSS    | ...                               |\r\n *\r\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\r\n *\r\n * @param date - The original date\r\n * @param format - The string of tokens\r\n *\r\n * @returns The formatted date string\r\n *\r\n * @throws `Invalid time value` if the date is invalid\r\n * @throws format string contains an unescaped latin alphabet character\r\n *\r\n * @example\r\n * const result = lightFormat(new Date(2014, 1, 11), 'yyyy-MM-dd')\r\n * //=> '2014-02-11'\r\n */\r\nfunction lightFormat(date, formatStr) {\r\n  const _date = (0, _index2.toDate)(date);\r\n\r\n  if (!(0, _index.isValid)(_date)) {\r\n    throw new RangeError(\"Invalid time value\");\r\n  }\r\n\r\n  const tokens = formatStr.match(formattingTokensRegExp);\r\n\r\n  // The only case when formattingTokensRegExp doesn't match the string is when it's empty\r\n  if (!tokens) return \"\";\r\n\r\n  const result = tokens\r\n    .map((substring) => {\r\n      // Replace two single quote characters with one single quote character\r\n      if (substring === \"''\") {\r\n        return \"'\";\r\n      }\r\n\r\n      const firstCharacter = substring[0];\r\n      if (firstCharacter === \"'\") {\r\n        return cleanEscapedString(substring);\r\n      }\r\n\r\n      const formatter = _index3.lightFormatters[firstCharacter];\r\n      if (formatter) {\r\n        return formatter(_date, substring);\r\n      }\r\n\r\n      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {\r\n        throw new RangeError(\r\n          \"Format string contains an unescaped latin alphabet character `\" +\r\n            firstCharacter +\r\n            \"`\",\r\n        );\r\n      }\r\n\r\n      return substring;\r\n    })\r\n    .join(\"\");\r\n\r\n  return result;\r\n}\r\n\r\nfunction cleanEscapedString(input) {\r\n  const matches = input.match(escapedStringRegExp);\r\n\r\n  if (!matches) {\r\n    return input;\r\n  }\r\n\r\n  return matches[1].replace(doubleQuoteRegExp, \"'\");\r\n}\r\n"],"mappings":"AAAA,YAAY;;AACZA,OAAO,CAACC,WAAW,GAAGA,WAAW;AACjCC,MAAM,CAACC,cAAc,CAACH,OAAO,EAAE,iBAAiB,EAAE;EAChDI,UAAU,EAAE,IAAI;EAChBC,GAAG,EAAE,SAAAA,CAAA,EAAY;IACf,OAAOC,OAAO,CAACC,eAAe;EAChC;AACF,CAAC,CAAC;AACF,IAAIC,MAAM,GAAGC,OAAO,CAAC,cAAc,CAAC;AACpC,IAAIC,OAAO,GAAGD,OAAO,CAAC,aAAa,CAAC;AACpC,IAAIH,OAAO,GAAGG,OAAO,CAAC,kCAAkC,CAAC;;AAEzD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,sBAAsB,GAAG,gCAAgC;AAE/D,MAAMC,mBAAmB,GAAG,cAAc;AAC1C,MAAMC,iBAAiB,GAAG,KAAK;AAC/B,MAAMC,6BAA6B,GAAG,UAAU;;AAEhD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASb,WAAWA,CAACc,IAAI,EAAEC,SAAS,EAAE;EACpC,MAAMC,KAAK,GAAG,CAAC,CAAC,EAAEP,OAAO,CAACQ,MAAM,EAAEH,IAAI,CAAC;EAEvC,IAAI,CAAC,CAAC,CAAC,EAAEP,MAAM,CAACW,OAAO,EAAEF,KAAK,CAAC,EAAE;IAC/B,MAAM,IAAIG,UAAU,CAAC,oBAAoB,CAAC;EAC5C;EAEA,MAAMC,MAAM,GAAGL,SAAS,CAACM,KAAK,CAACX,sBAAsB,CAAC;;EAEtD;EACA,IAAI,CAACU,MAAM,EAAE,OAAO,EAAE;EAEtB,MAAME,MAAM,GAAGF,MAAM,CAClBG,GAAG,CAAEC,SAAS,IAAK;IAClB;IACA,IAAIA,SAAS,KAAK,IAAI,EAAE;MACtB,OAAO,GAAG;IACZ;IAEA,MAAMC,cAAc,GAAGD,SAAS,CAAC,CAAC,CAAC;IACnC,IAAIC,cAAc,KAAK,GAAG,EAAE;MAC1B,OAAOC,kBAAkB,CAACF,SAAS,CAAC;IACtC;IAEA,MAAMG,SAAS,GAAGtB,OAAO,CAACC,eAAe,CAACmB,cAAc,CAAC;IACzD,IAAIE,SAAS,EAAE;MACb,OAAOA,SAAS,CAACX,KAAK,EAAEQ,SAAS,CAAC;IACpC;IAEA,IAAIC,cAAc,CAACJ,KAAK,CAACR,6BAA6B,CAAC,EAAE;MACvD,MAAM,IAAIM,UAAU,CAClB,gEAAgE,GAC9DM,cAAc,GACd,GACJ,CAAC;IACH;IAEA,OAAOD,SAAS;EAClB,CAAC,CAAC,CACDI,IAAI,CAAC,EAAE,CAAC;EAEX,OAAON,MAAM;AACf;AAEA,SAASI,kBAAkBA,CAACG,KAAK,EAAE;EACjC,MAAMC,OAAO,GAAGD,KAAK,CAACR,KAAK,CAACV,mBAAmB,CAAC;EAEhD,IAAI,CAACmB,OAAO,EAAE;IACZ,OAAOD,KAAK;EACd;EAEA,OAAOC,OAAO,CAAC,CAAC,CAAC,CAACC,OAAO,CAACnB,iBAAiB,EAAE,GAAG,CAAC;AACnD","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}